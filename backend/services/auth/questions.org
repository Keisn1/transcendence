#+title: Questions

- How do plugins work in fastify?
- How can I put a password on the database?

* Fastify plugins
** Fastify Plugins Overview

Plugins in Fastify are reusable pieces of functionality that extend the framework's capabilities. They follow an encapsulation model where each plugin has its own context.

** Code Examples

#+begin_src typescript
// Basic plugin structure
import fp from "fastify-plugin";

async function myPlugin(fastify, options) {
    // Add functionality to fastify instance
    fastify.decorate('myUtility', () => 'Hello World');

    // Register routes
    fastify.get('/plugin-route', async (request, reply) => {
        return { message: 'From plugin' };
    });
}

export default fp(myPlugin);
#+end_src

#+begin_src typescript
// Using the plugin
import Fastify from 'fastify';
import myPlugin from './my-plugin';

const fastify = Fastify();

// Register plugin
await fastify.register(myPlugin, {
    someOption: 'value'
});

// Now you can use decorated methods
console.log(fastify.myUtility()); // "Hello World"
#+end_src

#+begin_src typescript
// Plugin with encapsulation (without fp wrapper)
async function encapsulatedPlugin(fastify, options) {
    // This decoration only exists within this plugin's scope
    fastify.decorate('localUtility', () => 'Only here');

    fastify.get('/local-route', async () => {
        return fastify.localUtility();
    });
}

// Register without fp() - creates isolated scope
await fastify.register(encapsulatedPlugin);
#+end_src

** Metaphors

Think of Fastify plugins like *LEGO building blocks*:
- Each plugin is a specialized block (database, authentication, logging)
- You snap them together to build your application
- Some blocks (with =fp()=) share their features with the whole structure
- Others (without =fp()=) keep their features contained within their section

Or like *apartment building utilities*:
- Each plugin is like adding a utility (electricity, plumbing, internet)
- =fp()= makes utilities available to all apartments
- Without =fp()=, utilities are only available to specific floors

** For Dummies Section

*What's a plugin?* A chunk of code that adds new abilities to your Fastify server.

*How do they work?* You write a function that receives the Fastify instance and adds stuff to it (routes, utilities, etc.).

*The magic wrapper (=fp=)?* Without it, your plugin lives in its own bubble. With it, everything you add becomes available everywhere in your app.

*Why use them?* Instead of cramming everything into one giant file, you split features into organized, reusable pieces. Need database access? Write a plugin. Need authentication? Another plugin. Clean and modular!

***
* SQL statements
- query  (SELECT statements)
#+begin_src typescript :results output
  query: (sql: string, params: any[] = []) => {
      return new Promise((resolve, reject) => {
          db.all(sql, params, (err, rows) => {
              if (err) reject(err);
              else resolve(rows);
          });
      });
  }
    #+end_src
  - Uses =db.all()= - fetches all matching rows
  - Returns array of results
- run (INSERT/UPDATE/DELETE)
  #+begin_src typescript :results output
    run: (sql: string, params: any[] = []) => {
        return new Promise((resolve, reject) => {
            db.run(sql, params, function (err) {
                if (err) reject(err);
                else resolve({ lastID: this.lastID, changes: this.changes });
            });
        });
    }
  #+end_src
  - Uses =db.run()= - executes without returning data
  - Returns metadata: =lastID= (auto-increment) and =changes= (affected rows)

- explain async, await and Promise in that context
* Fastify Decoration
- what happens with this line
  #+begin_src typescript :results output
fastify.decorate("db", dbWrapper);
  #+end_src
  - Adds =dbWrapper= to Fastify instance as =fastify.db=. Now you can use:
    #+begin_src typescript
    await fastify.db.query("SELECT * FROM users")
    await fastify.db.run("INSERT INTO users ...")
  #+end_src
* Fastify Hooks
  #+begin_src typescript :results output
    fastify.addHook("onClose", async () => {
        return new Promise<void>((resolve) => {
            db.close((err) => {
                if (err) console.error("Error closing database:", err);
                resolve();
            });
        });
    });
  #+end_src
  - Registers cleanup function that runs when Fastify shuts down:
    - Properly closes SQLite database connection
    - Prevents "database locked" errors
    - Ensures graceful shutdown
* typescript module decalaration

Adds custom properties to Fastify's =FastifyInstance= interface so TypeScript knows about plugins you've registered.
* Database migration

For SQLite migrations with Fastify, you have a few options. Here's a simple but effective approach:
** 1. Create a migrations system

Create =migrations/001_initial.sql=:
#+begin_src sql
CREATE TABLE IF NOT EXISTS users (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    username TEXT UNIQUE NOT NULL,
    email TEXT UNIQUE NOT NULL,
    password_hash TEXT NOT NULL,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE IF NOT EXISTS schema_migrations (
    version INTEGER PRIMARY KEY,
    applied_at DATETIME DEFAULT CURRENT_TIMESTAMP
);
#+end_src

** 2. Update your database plugin

#+begin_src typescript
// plugins/database.ts
import fp from "fastify-plugin";
import sqlite3 from "sqlite3";
import { open } from "sqlite";
import fs from "fs/promises";
import path from "path";

async function runMigrations(db: any) {
    const migrationsDir = path.join(__dirname, "../migrations");

    // Ensure migrations table exists
    await db.exec(`
        CREATE TABLE IF NOT EXISTS schema_migrations (
            version INTEGER PRIMARY KEY,
            applied_at DATETIME DEFAULT CURRENT_TIMESTAMP
        )
    `);

    const files = await fs.readdir(migrationsDir);
    const migrations = files
        .filter(f => f.endsWith('.sql'))
        .sort();

    for (const file of migrations) {
        const version = parseInt(file.split('_')[0]);

        // Check if migration already applied
        const applied = await db.get(
            'SELECT version FROM schema_migrations WHERE version = ?',
            version
        );

        if (!applied) {
            const sql = await fs.readFile(path.join(migrationsDir, file), 'utf8');
            await db.exec(sql);
            await db.run(
                'INSERT INTO schema_migrations (version) VALUES (?)',
                version
            );
            console.log(`Applied migration: ${file}`);
        }
    }
}

async function databasePlugin(fastify: any) {
    const db = await open({
        filename: "./auth.db",
        driver: sqlite3.Database,
    });

    // Run migrations on startup
    await runMigrations(db);

    fastify.decorate("db", db);

    fastify.addHook("onClose", async () => {
        await db.close();
    });
}

export default fp(databasePlugin);
#+end_src

** 3. Create new migrations

For new changes, create =migrations/002_add_roles.sql=:
#+begin_src sql
ALTER TABLE users ADD COLUMN role TEXT DEFAULT 'user';
CREATE INDEX idx_users_role ON users(role);
#+end_src

This approach:
- Runs migrations automatically on startup
- Tracks applied migrations
- Allows incremental database changes
- Works well with SQLite's simplicity

*****
* node types
